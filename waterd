#!/usr/bin/env python3

from __future__ import division

import datetime
import io
import json
import pickle
import socket
import time
from collections import defaultdict, deque, namedtuple
from statistics import mean
from threading import Thread
from time import sleep

import Adafruit_GPIO.SPI as SPI
import Adafruit_MCP3008
import paho.mqtt.client
import pigpio
import pytz
import requests
from flask import Flask, render_template, send_file
from matplotlib.backends.backend_agg import FigureCanvasAgg as FigureCanvas
from matplotlib.dates import epoch2num, num2date, DateFormatter, DayLocator
from matplotlib.figure import Figure


# plant config
Plant = namedtuple("Plant", ("name", "pin", "channel", "line", "threshold"))
plants = [Plant(          "avocado",  20,    0,         11,     .45),
          Plant(      "dragonfruit",  21,    1,         12,     .00),
          Plant(         "laymoona",  22,    2,         13,     .00),
          Plant(        "palm bush",  23,    3,         14,     .00)]

# moisture reading config
read_interval = 60 * 10       # every ten minutes
window_length = 6 * 24 * 7    # one week
reads_per_log = 6             # one hour
def moisture_buffer(): return deque(maxlen=window_length)
readings = defaultdict(moisture_buffer)

# watering config
water_url = "http://admin:12345@192.168.0.100/script?run{:03}=run"
switch_auth = ("admin", 12345)
reads_per_watering_check = 6  # one hour
minimum_water_interval = 60 * 60 * 24 * 3   # three days
def watering_buffer(): return deque(maxlen=100)
waterings = defaultdict(watering_buffer)

# web config
port = 54700


# important objects
app = Flask(__name__)
gpio = pigpio.pi()
mcp = Adafruit_MCP3008.MCP3008(spi=SPI.SpiDev(0, 0))
mqttc = paho.mqtt.client.Client(socket.gethostname())


def log(msg):
    log_file = "/var/log/water.log"
    tstamp = datetime.datetime.now().isoformat()
    with open(log_file, 'a') as l:
        line = "{} - {}\n".format(tstamp, msg)
        l.write(line)

def avg(readings):
    return round(mean([r[1] for r in readings]), 3)

def read_moisture(pin, channel):
    gpio.write(pin, 1)
    sleep(.005)
    val = mcp.read_adc(channel) / 1024.0
    gpio.write(pin, 0)
    return val

def moisture_graph(plants):
    figure = Figure()
    ax = figure.add_subplot(111)
    for plant in plants:
        times, water_levels = zip(*readings[plant.name])
        dates = num2date(epoch2num(times))
        ax.plot_date(dates, water_levels, label=plant.name, fmt="-")
    ax.set_ylim(bottom=0.0, top=1.0)
    ax.legend(loc='upper center', bbox_to_anchor=(0.5, 1.05),
              ncol=4, fancybox=True, shadow=True)
    ax.xaxis.set_major_locator(DayLocator(
        tz=pytz.timezone("America/Los_Angeles")))
    ax.xaxis.set_major_formatter(DateFormatter('%m/%d',
        tz=pytz.timezone("America/Los_Angeles")))
    ax.yaxis.tick_right()

    canvas = FigureCanvas(figure)
    output = io.BytesIO()
    canvas.print_png(output)
    output.seek(0)
    return output

def monitor_water(plants):
    """ Thread target to periodically measure moisture levels. """
    ticks = 0
    while True:
        for plant in plants:
            moisture = round(read_moisture(plant.pin, plant.channel), 3)
            if moisture == 0.0: continue
            readings[plant.name].append((time.time(), moisture))
            mqttc.publish("plants/" + plant.name + "/moisture", moisture)

            if ticks % reads_per_log == 0:
                log("{}: {}".format(plant.name, avg(readings[plant.name])))

            if ticks % reads_per_watering_check == 0:
                if moisture < plant.threshold:
                    if waterings[plant.name]:
                        last_watering = waterings[plant.name][-1]
                    else:
                        # First watering ever. Assume plant is very thirsty.
                        last_watering = 0
                    time_since_water = time.time() - last_watering
                    if time_since_water > minimum_water_interval:
                        water_plant(plant)
        ticks = ticks + 1
        save_state()
        sleep(read_interval)

def water_plant(plant):
    log("watering {}".format(plant.name))
    waterings[plant.name].append(time.time())
    requests.get(water_url.format(plant.line))

def save_state():
    state = {'readings': readings,
             'waterings': waterings}
    with open("/home/science/water.pickle", "wb") as f:
        pickle.dump(state, f)

def load_state():
    with open("/home/science/water.pickle", "rb") as f:
        state = pickle.load(f)
        if 'readings' in state:
            old_readings = state['readings']
            for name, rs in old_readings.items():
                readings[name].extend(rs)
        if 'waterings' in state:
            old_waterings = state['waterings']
            for name, ws in old_waterings.items():
                waterings[name].extend(ws)

@app.route("/water_levels")
def water_levels():
    levels = dict((p.name, avg(p.readings)) for p in plants)
    return json.dumps(levels)

@app.route("/water_levels/live")
def live_water_levels():
    levels = dict((p.name, read_moisture(p.pin, p.channel)) for p in plants)
    return json.dumps(levels)

@app.route("/water_levels/graph")
def water_levels_graph():
    graph = moisture_graph(plants)
    return send_file(graph, mimetype="image/png")

@app.route("/")
def index():
    return render_template("water.html")

if __name__ == '__main__':
    log("****************")
    log("* Starting up! *")
    log("****************")

    load_state()

    mqttc.connect('bill')
    mqttc.loop_start()
    Thread(target=lambda: monitor_water(plants), daemon=True).start()
    app.run(host="0.0.0.0", port=port)
